<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Borrowing & References in Rust</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      background-color: #f7f7f7;
      margin: 0;
      padding: 0;
      color: #333;
    }
    header {
      background: #4CAF50;
      color: #fff;
      padding: 20px 0;
      text-align: center;
      margin-bottom: 20px;
    }
    .container {
      width: 90%;
      max-width: 1000px;
      margin: auto;
      overflow: hidden;
      background: #fff;
      padding: 20px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    h1, h2, h3 {
      margin-top: 0;
    }
    pre {
      background: #f4f4f4;
      padding: 10px;
      border-left: 3px solid #4CAF50;
      overflow-x: auto;
    }
    code {
      font-family: Consolas, monospace;
    }
    section {
      margin-bottom: 30px;
    }
    .example {
      margin-bottom: 20px;
    }
    .example h3 {
      background: #e2e2e2;
      padding: 5px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Borrowing & References in Rust</h1>
    <p>Erklärung und 20 Beispiele - wie ein Lehrer erklärt</p>
  </header>
  
  <div class="container">
    <section>
      <h2>Grundlagen</h2>
      <p>In Rust spielen <strong>Borrowing</strong> und Referenzen (mit <code>&amp;</code> für unveränderliche Referenzen und <code>&amp;mut</code> für veränderliche Referenzen) eine zentrale Rolle, um den Speicher sicher zu verwalten – ohne unnötige Kopien oder unkontrollierte Änderungen.</p>
      <ul>
        <li><strong>Ownership (Besitz):</strong> Jede Variable hat einen eindeutigen Besitzer. Sobald dieser den Gültigkeitsbereich verlässt, wird der Speicher freigegeben.</li>
        <li><strong>Borrowing:</strong> Anstatt Daten zu kopieren, können diese "ausgeliehen" werden:
          <ul>
            <li><code>&amp;</code> – für Lesezugriff (unveränderliche Referenz)</li>
            <li><code>&amp;mut</code> – für Schreibzugriff (veränderliche Referenz)</li>
          </ul>
        </li>
        <li>Regeln:
          <ul>
            <li>Beliebig viele unveränderliche Referenzen sind erlaubt.</li>
            <li>Nur eine veränderliche Referenz ist erlaubt, und keine unveränderliche Referenz darf existieren, solange die veränderliche Referenz lebt.</li>
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <h2>20 Beispiele</h2>

      <div class="example">
        <h3>1. Unveränderliche Referenz (Basic)</h3>
        <pre><code>fn main() {
    let zahl = 5;
    let ref_zahl = &zahl;
    println!("Die Zahl ist: {}", ref_zahl);
}</code></pre>
        <p><em>Erklärung:</em> Die Variable <code>zahl</code> wird unveränderlich referenziert.</p>
      </div>

      <div class="example">
        <h3>2. Veränderliche Referenz (Basic)</h3>
        <pre><code>fn main() {
    let mut zahl = 5;
    {
        let ref_mut = &mut zahl;
        *ref_mut += 1;
    }
    println!("Die Zahl ist: {}", zahl);
}</code></pre>
        <p><em>Erklärung:</em> Mit <code>&amp;mut</code> wird der Wert verändert.</p>
      </div>

      <div class="example">
        <h3>3. Mehrere unveränderliche Referenzen</h3>
        <pre><code>fn main() {
    let zahl = 5;
    let ref1 = &zahl;
    let ref2 = &zahl;
    println!("{} und {}", ref1, ref2);
}</code></pre>
        <p><em>Erklärung:</em> Mehrere unveränderliche Referenzen sind erlaubt.</p>
      </div>

      <div class="example">
        <h3>4. Wechselwirkung: Unveränderliche und veränderliche Referenzen</h3>
        <pre><code>fn main() {
    let mut zahl = 5;
    let ref1 = &zahl;
    // let ref_mut = &mut zahl; // Compilerfehler!
    println!("Unveränderliche Referenz: {}", ref1);
}</code></pre>
        <p><em>Erklärung:</em> Eine veränderliche Referenz kann nicht erstellt werden, wenn schon eine unveränderliche existiert.</p>
      </div>

      <div class="example">
        <h3>5. Verändern mit <code>&amp;mut</code></h3>
        <pre><code>fn main() {
    let mut text = String::from("Hallo");
    {
        let text_mut = &mut text;
        text_mut.push_str(", Welt!");
    }
    println!("{}", text);
}</code></pre>
        <p><em>Erklärung:</em> Der String wird über eine veränderliche Referenz modifiziert.</p>
      </div>

      <div class="example">
        <h3>6. Funktion mit unveränderlicher Referenz als Parameter</h3>
        <pre><code>fn drucke_zahl(z: &i32) {
    println!("Die Zahl ist: {}", z);
}

fn main() {
    let zahl = 10;
    drucke_zahl(&zahl);
}</code></pre>
        <p><em>Erklärung:</em> Der Wert wird durch eine unveränderliche Referenz an die Funktion übergeben.</p>
      </div>

      <div class="example">
        <h3>7. Funktion mit veränderlicher Referenz als Parameter</h3>
        <pre><code>fn erhoehe(z: &mut i32) {
    *z += 1;
}

fn main() {
    let mut zahl = 10;
    erhoehe(&mut zahl);
    println!("Erhöhte Zahl: {}", zahl);
}</code></pre>
        <p><em>Erklärung:</em> Die Funktion verändert den Wert über die veränderliche Referenz.</p>
      </div>

      <div class="example">
        <h3>8. Mehrere Funktionsaufrufe mit unveränderlichen Referenzen</h3>
        <pre><code>fn zeige(z: &i32) {
    println!("Wert: {}", z);
}

fn main() {
    let zahl = 20;
    zeige(&zahl);
    zeige(&zahl);
}</code></pre>
        <p><em>Erklärung:</em> Mehrere Aufrufe können dieselbe unveränderliche Referenz nutzen.</p>
      </div>

      <div class="example">
        <h3>9. Bereichsbeschränkung für veränderliche Referenzen</h3>
        <pre><code>fn main() {
    let mut zahl = 15;
    {
        let ref_mut = &mut zahl;
        *ref_mut += 5;
    } // Ende des Gültigkeitsbereichs von ref_mut
    let ref2 = &zahl;
    println!("Wert: {}", ref2);
}</code></pre>
        <p><em>Erklärung:</em> Nach Ende des Blocks ist es wieder möglich, unveränderliche Referenzen zu erstellen.</p>
      </div>

      <div class="example">
        <h3>10. Slice-Borrowing (Unveränderlich)</h3>
        <pre><code>fn zeige_slice(slice: &str) {
    println!("Slice: {}", slice);
}

fn main() {
    let text = String::from("Rust ist toll");
    zeige_slice(&text);
}</code></pre>
        <p><em>Erklärung:</em> Der String wird als Slice über eine unveränderliche Referenz übergeben.</p>
      </div>

      <div class="example">
        <h3>11. Slice-Borrowing (Veränderlich)</h3>
        <pre><code>fn aendere_slice(slice: &mut String) {
    slice.push_str(" und sicher!");
}

fn main() {
    let mut text = String::from("Rust ist toll");
    aendere_slice(&mut text);
    println!("{}", text);
}</code></pre>
        <p><em>Erklärung:</em> Eine veränderliche Referenz ändert den Inhalt des Strings.</p>
      </div>

      <div class="example">
        <h3>12. Borrowing in Schleifen</h3>
        <pre><code>fn main() {
    let zahlen = vec![1, 2, 3, 4, 5];
    for zahl in &zahlen {
        println!("Zahl: {}", zahl);
    }
}</code></pre>
        <p><em>Erklärung:</em> Die Schleife leiht sich unveränderlich die Elemente des Vektors.</p>
      </div>

      <div class="example">
        <h3>13. Borrowing mit Iteratoren</h3>
        <pre><code>fn main() {
    let zahlen = vec![1, 2, 3];
    let verdoppelt: Vec<i32> = zahlen.iter().map(|x| x * 2).collect();
    println!("{:?}", verdoppelt);
}</code></pre>
        <p><em>Erklärung:</em> <code>iter()</code> leiht sich die Elemente, während <code>map</code> diese verarbeitet.</p>
      </div>

      <div class="example">
        <h3>14. Referenzen in Strukturen</h3>
        <pre><code>struct Person<'a> {
    name: &'a str,
}

fn main() {
    let name = "Alice";
    let person = Person { name };
    println!("Name: {}", person.name);
}</code></pre>
        <p><em>Erklärung:</em> Eine Struktur kann Referenzen enthalten – mit einer definierten Lebensdauer.</p>
      </div>

      <div class="example">
        <h3>15. Mehrfache Borrowing innerhalb eines Funktionsaufrufs</h3>
        <pre><code>fn addiere(a: &i32, b: &i32) -> i32 {
    a + b
}

fn main() {
    let x = 10;
    let y = 20;
    println!("Summe: {}", addiere(&x, &y));
}</code></pre>
        <p><em>Erklärung:</em> Zwei unveränderliche Referenzen werden zur Berechnung verwendet.</p>
      </div>

      <div class="example">
        <h3>16. Borrowing in verschachtelten Funktionen</h3>
        <pre><code>fn aussen(z: &i32) {
    fn innen(inner_z: &i32) {
        println!("Innerer Wert: {}", inner_z);
    }
    innen(z);
}

fn main() {
    let wert = 42;
    aussen(&wert);
}</code></pre>
        <p><em>Erklärung:</em> Eine innere Funktion erhält eine Referenz aus der äußeren Funktion.</p>
      </div>

      <div class="example">
        <h3>17. Borrowing mit Struct-Methoden (immutable)</h3>
        <pre><code>struct Punkt {
    x: i32,
    y: i32,
}

impl Punkt {
    fn zeige(&self) {
        println!("Punkt: ({}, {})", self.x, self.y);
    }
}

fn main() {
    let p = Punkt { x: 3, y: 4 };
    p.zeige();
}</code></pre>
        <p><em>Erklärung:</em> Die Methode leiht sich unveränderlich die Felder des Structs.</p>
      </div>

      <div class="example">
        <h3>18. Borrowing mit Struct-Methoden (mutable)</h3>
        <pre><code>struct Zaehler {
    wert: i32,
}

impl Zaehler {
    fn erhoehe(&mut self) {
        self.wert += 1;
    }
}

fn main() {
    let mut counter = Zaehler { wert: 0 };
    counter.erhoehe();
    println!("Wert: {}", counter.wert);
}</code></pre>
        <p><em>Erklärung:</em> Die Methode ändert den Zustand des Structs über <code>&amp;mut self</code>.</p>
      </div>

      <div class="example">
        <h3>19. Rückgabe von Referenzen aus Funktionen</h3>
        <pre><code>fn gib_ref<'a>(s: &'a String) -> &'a str {
    &s[0..3]
}

fn main() {
    let text = String::from("Rustacean");
    let teil = gib_ref(&text);
    println!("Teil: {}", teil);
}</code></pre>
        <p><em>Erklärung:</em> Mithilfe von Lebensdauern wird sichergestellt, dass die zurückgegebene Referenz gültig bleibt.</p>
      </div>

      <div class="example">
        <h3>20. Kombination von unveränderlichen und veränderlichen Borrowing in getrennten Blöcken</h3>
        <pre><code>fn main() {
    let mut daten = vec![1, 2, 3];
    
    // Unveränderliche Referenz in diesem Block
    {
        let erste = &daten[0];
        println!("Erstes Element: {}", erste);
    }
    
    // Verändere die Daten in einem neuen Block
    {
        let daten_mut = &mut daten;
        daten_mut.push(4);
    }
    
    println!("Aktualisierte Daten: {:?}", daten);
}</code></pre>
        <p><em>Erklärung:</em> Durch getrennte Blöcke können unveränderliche und veränderliche Referenzen sicher kombiniert werden.</p>
      </div>
    </section>

    <section>
      <h2>Zusammenfassung</h2>
      <p>Die Beispiele zeigen, wie Rust mit Borrowing und Referenzen (<code>&amp;</code> und <code>&amp;mut</code>) eine sichere Speicherverwaltung gewährleistet. Während <code>&amp;</code> den Lesezugriff ohne Besitzübertragung erlaubt, ermöglicht <code>&amp;mut</code> kontrollierte Änderungen – beides verhindert Datenrennen und unerwartete Nebeneffekte.</p>
    </section>
  </div>
</body>
</html>
